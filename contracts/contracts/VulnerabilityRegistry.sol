// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"

/**
 * @title VulnerabilityRegistry
 * @dev Immutable on-chain registry for smart contract audit vulnerabilities
 */
contract VulnerabilityRegistry is Ownable {
    
    struct VulnerabilitySummary {
        uint16 critical;
        uint16 high;
        uint16 medium;
        uint16 low;
    }
    
    struct VulnerabilityDetail {
        string vulnType;              
        uint8 severity;              
        bytes32 descriptionHash;   
        uint32 lineNumber;         
        bool autofixed;              
        bytes32 fixHash;           
    }
    
    struct AuditEntry {
        bytes32 auditId;
        bytes32 contractHash;
        bytes32 fixedCodeHash;
        bytes32 llmOutputHash;
        address auditorAddress;
        uint256 timestamp;
        uint8 riskScore;
        bool autoFixApplied;
        uint16 totalVulnerabilities;
        VulnerabilitySummary summary;
        string ipfsReportCID;
        string ipfsFixedCodeCID;
        uint256 networkId;
        bool exists;
    }
    
    // contractHash => AuditEntry
    mapping(bytes32 => AuditEntry) public audits;
    
    // auditId => contractHash (reverse lookup)
    mapping(bytes32 => bytes32) public auditIdToContractHash;
    
    // contractHash => vulnerabilityId[] 
    mapping(bytes32 => bytes32[]) public auditVulnerabilities;
    
    // vulnerabilityId => VulnerabilityDetail
    mapping(bytes32 => VulnerabilityDetail) public vulnerabilities;
    
    // contractHash => exists (prevent duplicates)
    mapping(bytes32 => bool) public contractAudited;
    
    // auditor => auditIds[]
    mapping(address => bytes32[]) public auditorAudits;
    
    // Authorized minters (backend wallet)
    mapping(address => bool) public authorizedMinters;
    
    event AuditRegistered(
        bytes32 indexed auditId,
        bytes32 indexed contractHash,
        address indexed auditor,
        uint8 riskScore,
        uint16 totalVulnerabilities
    );
    
    event VulnerabilityRecorded(
        bytes32 indexed auditId,
        bytes32 indexed vulnerabilityId,
        string vulnType,
        uint8 severity
    );
    
    constructor() Ownable(msg.sender) {
        authorizedMinters[msg.sender] = true;
    }
    
    modifier onlyAuthorized() {
        require(authorizedMinters[msg.sender], "Not authorized");
        _;
    }
    
    function setAuthorizedMinter(address minter, bool authorized) external onlyOwner {
        authorizedMinters[minter] = authorized;
    }
    
    /**
     * @dev Register a new audit with vulnerabilities
     */
    function registerAudit(
        bytes32 auditId,
        bytes32 contractHash,
        bytes32 fixedCodeHash,
        bytes32 llmOutputHash,
        address auditorAddress,
        uint8 riskScore,
        bool autoFixApplied,
        VulnerabilitySummary memory summary,
        string memory ipfsReportCID,
        string memory ipfsFixedCodeCID,
        uint256 networkId,
        VulnerabilityDetail[] memory vulnDetails
    ) external onlyAuthorized returns (bool) {
        require(!contractAudited[contractHash], "Contract already audited");
        require(auditId != bytes32(0), "Invalid audit ID");
        require(contractHash != bytes32(0), "Invalid contract hash");
        
        uint16 totalVulns = summary.critical + summary.high + summary.medium + summary.low;
        
        AuditEntry memory entry = AuditEntry({
            auditId: auditId,
            contractHash: contractHash,
            fixedCodeHash: fixedCodeHash,
            llmOutputHash: llmOutputHash,
            auditorAddress: auditorAddress,
            timestamp: block.timestamp,
            riskScore: riskScore,
            autoFixApplied: autoFixApplied,
            totalVulnerabilities: totalVulns,
            summary: summary,
            ipfsReportCID: ipfsReportCID,
            ipfsFixedCodeCID: ipfsFixedCodeCID,
            networkId: networkId,
            exists: true
        });
        
        audits[contractHash] = entry;
        auditIdToContractHash[auditId] = contractHash;
        contractAudited[contractHash] = true;
        auditorAudits[auditorAddress].push(auditId);
        
        // Store vulnerability details
        for (uint i = 0; i < vulnDetails.length; i++) {
            bytes32 vulnId = keccak256(abi.encodePacked(auditId, i));
            vulnerabilities[vulnId] = vulnDetails[i];
            auditVulnerabilities[contractHash].push(vulnId);
            
            emit VulnerabilityRecorded(
                auditId,
                vulnId,
                vulnDetails[i].vulnType,
                vulnDetails[i].severity
            );
        }
        
        emit AuditRegistered(
            auditId,
            contractHash,
            auditorAddress,
            riskScore,
            totalVulns
        );
        
        return true;
    }
    
    /**
     * @dev Check if contract has been audited
     */
    function isContractAudited(bytes32 contractHash) external view returns (bool) {
        return contractAudited[contractHash];
    }
    
    /**
     * @dev Get audit entry by contract hash
     */
    function getAudit(bytes32 contractHash) external view returns (AuditEntry memory) {
        require(audits[contractHash].exists, "Audit not found");
        return audits[contractHash];
    }
    
    /**
     * @dev Get audit entry by audit ID
     */
    function getAuditById(bytes32 auditId) external view returns (AuditEntry memory) {
        bytes32 contractHash = auditIdToContractHash[auditId];
        require(audits[contractHash].exists, "Audit not found");
        return audits[contractHash];
    }
    
    /**
     * @dev Get vulnerabilities for an audit
     */
    function getVulnerabilities(bytes32 contractHash) external view returns (bytes32[] memory) {
        return auditVulnerabilities[contractHash];
    }
    
    /**
     * @dev Get vulnerability detail
     */
    function getVulnerabilityDetail(bytes32 vulnId) external view returns (VulnerabilityDetail memory) {
        return vulnerabilities[vulnId];
    }
    
    /**
     * @dev Get all audits by auditor
     */
    function getAuditorAudits(address auditor) external view returns (bytes32[] memory) {
        return auditorAudits[auditor];
    }
    
    /**
     * @dev Get severity summary
     */
    function getSeveritySummary(bytes32 contractHash) external view returns (VulnerabilitySummary memory) {
        require(audits[contractHash].exists, "Audit not found");
        return audits[contractHash].summary;
    }
}